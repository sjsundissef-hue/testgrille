<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>WordBox Mobile</title>
  <style>
    /* =========================================
       CSS (STYLE CORRIGÉ POUR MOBILE)
       ========================================= */
    :root {
      --bg-color: #f4f4eb;
      --case-bg: #ffffff;
      --case-shadow: #c8c8be;
      --case-selected: #d4f1f4;
      --case-border-selected: #4a90e2;
      --text-color: #333333;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent; /* Supprime le flash bleu au clic */
    }

    body {
      margin: 0;
      padding: 10px;
      /* FIGER L'ÉCRAN : */
      height: 100dvh; 
      width: 100vw;
      overflow: hidden; /* Empêche tout défilement de la page */
      position: fixed;  /* Fixe le corps de page */
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: var(--bg-color);
      font-family: "Segoe UI", sans-serif;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none; /* Désactive les gestes navigateur */
    }

    /* En-tête compact */
    h1 {
      margin: 5px 0 5px 0;
      color: #444;
      text-transform: uppercase;
      letter-spacing: 3px;
      font-size: 1.2rem;
      text-align: center;
      flex-shrink: 0;
    }

    /* CONTROLS (Boutons haut) */
    .controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 5px;
      width: 100%;
      flex-shrink: 0;
    }

    .control-group {
      display: flex;
      gap: 5px;
      background: #e6e6e6;
      padding: 3px;
      border-radius: 999px;
    }

    .mode-btn, .layout-btn {
      padding: 6px 14px;
      font-size: 0.8rem;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: #777;
      font-weight: 700;
      cursor: pointer;
    }

    .mode-btn.active, .layout-btn.active {
      background: #ffffff;
      color: #4a90e2;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    /* ZONE PRINCIPALE */
    .main-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-evenly; /* Répartit l'espace */
      width: 100%;
      height: 100%;
      padding-bottom: 10px;
    }

    /* SCORE PANEL */
    .score-panel {
      background: #ffffff;
      padding: 8px 20px;
      border-radius: 15px;
      width: 90%;
      max-width: 360px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      flex-shrink: 0;
      margin-bottom: 5px;
    }

    .score-title { font-size: 0.9rem; font-weight: 700; color: #555; }
    .score-total { font-size: 1.6rem; font-weight: 900; color: #4a90e2; }

    /* MOT COURANT */
    .word-display-area {
      height: 60px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      flex-shrink: 0;
    }

    .current-word {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: 2px;
      color: #333;
      min-height: 40px;
    }

    .feedback {
      font-size: 0.85rem;
      font-weight: 600;
      height: 20px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .feedback.visible { opacity: 1; }
    .feedback.valid { color: #27ae60; }
    .feedback.invalid { color: #e74c3c; }

    /* GRILLE WRAPPER */
    .grid-wrapper {
      position: relative;
      padding: 15px;
      background: #dcdcd0;
      border-radius: 30px;
      box-shadow: inset 0 3px 6px rgba(0,0,0,0.1);
      touch-action: none; /* CRUCIAL pour le drag tactile */
      width: 92vw;
      max-width: 360px;
      aspect-ratio: 1/1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid {
      display: grid;
      width: 100%;
      height: 100%;
      align-content: center;
      justify-content: center;
    }

    /* Espacements dynamiques */
    .grid.grid-4x4 { grid-template-columns: repeat(4, 1fr); gap: 12px; }
    .grid.grid-5x5 { grid-template-columns: repeat(5, 1fr); gap: 8px; }

    /* CELLULES */
    .cell {
      width: 100%;
      aspect-ratio: 1/1;
      background-color: var(--case-bg);
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.4rem, 6vw, 2rem);
      font-weight: 800;
      color: var(--text-color);
      box-shadow: 0 6px 0 var(--case-shadow);
      cursor: pointer;
      transition: transform 0.1s, background-color 0.1s;
      user-select: none;
    }

    .cell.selected {
      background-color: var(--case-selected);
      box-shadow: 0 3px 0 #a8d8e0, inset 0 0 0 3px var(--case-border-selected);
      transform: translateY(3px);
    }

    /* LISTE DE MOTS (cachée visuellement mais présente dans le DOM pour JS) */
    .word-list-container { display: none; }

    /* BOUTONS BAS */
    .actions-bottom {
      display: flex;
      gap: 15px;
      margin-top: 10px;
      flex-shrink: 0;
    }

    button.action-btn {
      border: none;
      border-radius: 999px;
      padding: 12px 24px;
      font-weight: 700;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 0 4px 0 rgba(0,0,0,0.2);
      color: #fff;
      transition: transform 0.1s;
    }

    button.btn-new { background: #4a90e2; box-shadow: 0 4px 0 #2c6eb3; }
    button.btn-clear { background: #e74c3c; box-shadow: 0 4px 0 #c0392b; }
    
    button.action-btn:active {
      transform: translateY(3px);
      box-shadow: 0 1px 0 rgba(0,0,0,0.2);
    }

  </style>
</head>
<body>

  <h1>WordBox</h1>

  <div class="controls">
    <div class="control-group">
      <button id="btn4x4" class="mode-btn active">4x4</button>
      <button id="btn5x5" class="mode-btn">5x5</button>
    </div>
    <div class="control-group">
      <button class="layout-btn active" data-layout="A">A</button>
      <button class="layout-btn" data-layout="B">B</button>
      <button class="layout-btn" data-layout="C">C</button>
    </div>
  </div>

  <div class="main-container">

    <div class="score-panel">
      <span class="score-title">SCORE</span>
      <span id="scoreDisplay" class="score-total">0</span>
    </div>

    <div class="word-display-area">
      <div id="currentWord" class="current-word"></div>
      <div id="feedbackMsg" class="feedback"></div>
    </div>

    <div id="gridWrapper" class="grid-wrapper layout-A">
      <div id="grid" class="grid grid-4x4">
        </div>
    </div>

    <div class="actions-bottom">
      <button id="clearWordBtn" class="action-btn btn-clear">Effacer</button>
      <button id="newGridBtn" class="action-btn btn-new">Nouvelle</button>
    </div>

  </div>

  <ul id="wordList" class="word-list-container"></ul>
  <div style="display:none">
    <span id="gridSizeLabel"></span>
    <span id="layoutLabel"></span>
  </div>

  <script>
    // ===========================
    // JAVASCRIPT (LOGIQUE DU JEU)
    // ===========================

    let gridSize = 4;            
    let gridData = [];           
    let foundWords = new Set();  
    let selectionPath = [];      
    let isDragging = false;

    // Lettres (Distribution "Scrabble-ish" pour le français/anglais)
    const LETTERS = "AAAAABCDEEEEEFGHIIIIJKLMNOOOOPQRSTUUUUUVWXYYZ";

    // DOM Elements
    const gridWrapper = document.getElementById("gridWrapper");
    const gridEl = document.getElementById("grid");
    const wordDisplay = document.getElementById("currentWord");
    const feedbackEl = document.getElementById("feedbackMsg");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const wordListEl = document.getElementById("wordList");
    const gridSizeLabel = document.getElementById("gridSizeLabel");
    const layoutLabel = document.getElementById("layoutLabel");

    const btn4x4 = document.getElementById("btn4x4");
    const btn5x5 = document.getElementById("btn5x5");
    const layoutButtons = document.querySelectorAll(".layout-btn");
    const newGridBtn = document.getElementById("newGridBtn");
    const clearWordBtn = document.getElementById("clearWordBtn");

    let currentLayout = "A";

    // --- GÉNÉRATION ---
    function generateGrid() {
      gridData = Array.from({ length: gridSize }, () =>
        Array.from({ length: gridSize }, () => {
          const idx = Math.floor(Math.random() * LETTERS.length);
          return LETTERS[idx];
        })
      );
    }

    function renderGrid() {
      if (!gridEl) return;
      gridEl.innerHTML = "";

      gridEl.classList.remove("grid-4x4", "grid-5x5");
      gridEl.classList.add(gridSize === 4 ? "grid-4x4" : "grid-5x5");

      gridData.forEach((row, r) => {
        row.forEach((letter, c) => {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.textContent = letter;
          cell.dataset.r = r;
          cell.dataset.c = c;

          // Souris
          cell.addEventListener("mousedown", (e) => startDrag(e, cell));
          cell.addEventListener("mouseenter", (e) => onDragEnter(e, cell));

          // Touchstart
          cell.addEventListener("touchstart", (e) => {
              // Important : preventDefault empêche parfois le clic, 
              // on le garde ici pour initier le drag proprement sans emuler la souris
              e.preventDefault(); 
              startDrag(e, cell);
            }, { passive: false }
          );

          gridEl.appendChild(cell);
        });
      });
      updateWordDisplay();
    }

    // --- DRAG LOGIC ---
    function startDrag(e, cell) {
      if (!cell) return;
      isDragging = true;
      selectionPath = [{
        r: parseInt(cell.dataset.r, 10),
        c: parseInt(cell.dataset.c, 10),
      }];
      updateVisuals();
    }

    function onDragEnter(e, cell) {
      if (!isDragging || !cell) return;
      addToPath(
        parseInt(cell.dataset.r, 10),
        parseInt(cell.dataset.c, 10)
      );
    }

    // Touchmove global : le secret pour que ça marche bien sur mobile
    document.addEventListener("touchmove", (e) => {
        if (!isDragging) return;
        // CRUCIAL : Empêche le scroll de l'écran pendant qu'on joue
        e.preventDefault(); 
        
        const touch = e.touches[0];
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        const cell = el && el.closest(".cell");
        
        if (cell) {
          addToPath(
            parseInt(cell.dataset.r, 10),
            parseInt(cell.dataset.c, 10)
          );
        }
      }, { passive: false } // passive false est obligatoire pour preventDefault
    );

    function endDrag() {
      if (!isDragging) return;
      isDragging = false;
      validateWord();
      selectionPath = [];
      updateVisuals();
    }

    document.addEventListener("mouseup", endDrag);
    document.addEventListener("touchend", endDrag);

    function addToPath(r, c) {
      // Retour en arrière ?
      if (selectionPath.length > 1) {
        const prev = selectionPath[selectionPath.length - 2];
        if (prev.r === r && prev.c === c) {
          selectionPath.pop();
          updateVisuals();
          return;
        }
      }

      const last = selectionPath[selectionPath.length - 1];
      // Adjacence (diagonales comprises)
      const isAdj = Math.abs(last.r - r) <= 1 && Math.abs(last.c - c) <= 1;
      // Pas déjà visité
      const isVisited = selectionPath.some((p) => p.r === r && p.c === c);

      if (isAdj && !isVisited) {
        selectionPath.push({ r, c });
        updateVisuals();
      }
    }

    function updateVisuals() {
      if (!gridEl) return;
      const cells = Array.from(gridEl.children);
      cells.forEach((el) => el.classList.remove("selected"));

      let word = "";
      selectionPath.forEach((pos) => {
        // Calcul de l'index à plat pour retrouver la div
        const idx = pos.r * gridSize + pos.c;
        const cell = cells[idx];
        if (cell) {
          cell.classList.add("selected");
          word += gridData[pos.r][pos.c];
        }
      });

      if (wordDisplay) wordDisplay.textContent = word;
    }

    // --- SCORE ---
    function getWordPoints(word) {
      const len = word.length;
      if (len < 3) return 0;
      if (len === 3) return 1; // Ajusté : 3 lettres = 1 pt souvent
      if (len === 4) return 2;
      if (len === 5) return 4;
      if (len === 6) return 6;
      return 10;
    }

    function validateWord() {
      const word = wordDisplay ? wordDisplay.textContent : "";
      if (!word || word.length < 3) {
        if (word.length > 0) showFeedback("Trop court", "invalid");
        return;
      }

      if (foundWords.has(word)) {
        showFeedback("Déjà trouvé", "invalid");
        return;
      }

      foundWords.add(word);
      const pts = getWordPoints(word);
      const oldScore = parseInt(scoreDisplay.textContent || "0", 10) || 0;
      const newScore = oldScore + pts;
      if (scoreDisplay) scoreDisplay.textContent = newScore.toString();

      showFeedback(`+${pts} pts`, "valid");
    }

    function showFeedback(text, type) {
      if (!feedbackEl) return;
      feedbackEl.textContent = text;
      feedbackEl.className = "feedback visible" + (type ? " " + type : "");
      
      // Petit délai pour cacher
      setTimeout(() => {
          feedbackEl.className = "feedback"; // cache
      }, 1000);
    }

    function updateWordDisplay() {
      // Sert si on veut rafraîchir manuellement, rarement utile ici
      let word = "";
      selectionPath.forEach((pos) => {
        word += gridData[pos.r][pos.c];
      });
      if (wordDisplay) wordDisplay.textContent = word;
    }

    // --- CONTROLES ---
    function setGridSize(size) {
      gridSize = size;
      if (gridSizeLabel) gridSizeLabel.textContent = gridSize + "x" + gridSize;

      if (btn4x4) btn4x4.classList.toggle("active", size === 4);
      if (btn5x5) btn5x5.classList.toggle("active", size === 5);

      resetGame();
    }

    function setLayout(layout) {
      currentLayout = layout;
      if (layoutLabel) layoutLabel.textContent = layout;

      layoutButtons.forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.layout === layout);
      });

      gridWrapper.classList.remove("layout-A", "layout-B", "layout-C");
      gridWrapper.classList.add("layout-" + layout);
      
      // Ici on peut aussi changer le gap CSS via JS si on veut être strict,
      // mais les classes CSS .layout-A .grid s'en occupent déjà.
    }

    function resetGame() {
      foundWords.clear();
      selectionPath = [];
      if (scoreDisplay) scoreDisplay.textContent = "0";
      if (wordDisplay) wordDisplay.textContent = "";
      if (feedbackEl) {
        feedbackEl.textContent = "";
        feedbackEl.className = "feedback";
      }
      generateGrid();
      renderGrid();
    }

    // Listeners Boutons
    if (btn4x4) btn4x4.addEventListener("click", () => setGridSize(4));
    if (btn5x5) btn5x5.addEventListener("click", () => setGridSize(5));

    layoutButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const layout = btn.dataset.layout || "A";
        setLayout(layout);
      });
    });

    if (newGridBtn) {
      newGridBtn.addEventListener("click", () => {
        resetGame();
        showFeedback("Nouvelle grille", "valid");
      });
    }

    if (clearWordBtn) {
      clearWordBtn.addEventListener("click", () => {
        selectionPath = [];
        updateVisuals();
        showFeedback("", "");
      });
    }

    // Init au chargement
    window.addEventListener("load", () => {
      setLayout("A");
      setGridSize(4);
    });

  </script>
</body>
</html>